[{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\api\\hooks\\index.test.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (60). Maximum allowed is 50.","line":21,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":97,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { act, renderHook } from '@testing-library/react';\r\nimport {\r\n  useCreateReminder,\r\n  useDeleteReminder,\r\n  useReminder,\r\n  useReminderActions,\r\n  useReminders,\r\n  useUpdateReminder,\r\n} from '.';\r\nimport { mockReminder, mockReminders } from '@/app/util/testMocks';\r\n\r\njest.mock(\r\n  '@/app/api',\r\n  () => require('@/app/util/testMocks').jestFunctionsMock['@/app/api'],\r\n);\r\njest.mock('@/app/hooks', () => ({\r\n  useMutation: jest.fn(),\r\n  useQuery: jest.fn().mockImplementation(() => mockReminders),\r\n}));\r\n\r\ndescribe('Reminder Hooks', () => {\r\n  beforeEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  it('useReminders hook', () => {\r\n    const { result } = renderHook(() => useReminders());\r\n\r\n    expect(result.current).toEqual(mockReminders);\r\n  });\r\n\r\n  it('useReminder hook', () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useQuery')\r\n      .mockImplementation(() => mockReminder);\r\n\r\n    const { result } = renderHook(() => useReminder('1'));\r\n\r\n    expect(result.current).toEqual(mockReminder);\r\n  });\r\n\r\n  it('useCreateReminder hook', () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useMutation')\r\n      .mockImplementation(() => ({ mutateAsync: jest.fn() }));\r\n\r\n    const { result } = renderHook(() => useCreateReminder());\r\n\r\n    act(() => {\r\n      (result.current as any).mutateAsync();\r\n    });\r\n    expect(result.current.mutateAsync).toHaveBeenCalled();\r\n  });\r\n\r\n  it('useUpdateReminder hook', () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useMutation')\r\n      .mockImplementation(() => ({ mutateAsync: jest.fn() }));\r\n\r\n    const { result } = renderHook(() => useUpdateReminder());\r\n\r\n    act(() => {\r\n      (result.current as any).mutateAsync();\r\n    });\r\n    expect(result.current.mutateAsync).toHaveBeenCalled();\r\n  });\r\n\r\n  it('useDeleteReminder hook', () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useMutation')\r\n      .mockImplementation(() => ({ mutateAsync: jest.fn() }));\r\n\r\n    const { result } = renderHook(() => useDeleteReminder());\r\n\r\n    act(() => {\r\n      (result.current as any).mutateAsync();\r\n    });\r\n    expect(result.current.mutateAsync).toHaveBeenCalled();\r\n  });\r\n\r\n  it('useReminderActions hook', () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useMutation')\r\n      .mockImplementation(() => ({ mutateAsync: jest.fn() }));\r\n\r\n    const { result } = renderHook(() => useReminderActions());\r\n\r\n    act(() => {\r\n      (result.current as any).createReminder.mutateAsync();\r\n      (result.current as any).updateReminder.mutateAsync();\r\n      (result.current as any).deleteReminder.mutateAsync();\r\n    });\r\n    expect(result.current.createReminder.mutateAsync).toHaveBeenCalled();\r\n    expect(result.current.updateReminder.mutateAsync).toHaveBeenCalled();\r\n    expect(result.current.deleteReminder.mutateAsync).toHaveBeenCalled();\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\api\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\api\\index.test.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (199). Maximum allowed is 50.","line":13,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":244,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (11). Maximum allowed is 10.","line":13,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":244,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  getReminders,\r\n  getReminder,\r\n  createReminder,\r\n  updateReminder,\r\n  deleteReminder,\r\n  Reminder,\r\n  API_BASE_URL,\r\n  Errors,\r\n  getErrors,\r\n} from './index';\r\n\r\ndescribe('API functions', () => {\r\n  const mockValidationFail = {\r\n    type: 'https://tools.ietf.org/html/rfc9110#section-15.5.1',\r\n    title: 'One or more validation errors occurred.',\r\n    status: 400,\r\n    errors: {\r\n      Title: [\"The field Title must be a text with a maximum length of '50'.\"],\r\n      Description: [\r\n        \"The field Description must be a text with a maximum length of '200'.\",\r\n      ],\r\n      'LimitDate.Date': ['The Limit Date should be later than Today.'],\r\n    },\r\n    traceId: '00-852bcb95dfb240075f3f8442bb60e22d-c4a9101dd7a52296-00',\r\n  };\r\n\r\n  const mockReminder: Reminder = {\r\n    title: 'Test Reminder',\r\n    description: 'This is a test reminder',\r\n    limitDate: '2022-01-01',\r\n    limitDateFormatted: '2022-01-01',\r\n    isDone: false,\r\n    isDoneFormatted: 'No',\r\n  };\r\n\r\n  beforeEach(() => {\r\n    // Mock the fetch function\r\n    global.fetch = jest.fn();\r\n  });\r\n\r\n  afterEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  describe('getReminders', () => {\r\n    it('should fetch reminders from the API', async () => {\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce([{ id: '1', ...mockReminder }]),\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const reminders = await getReminders();\r\n\r\n      expect(global.fetch).toHaveBeenCalledWith(\r\n        `${API_BASE_URL}/api/reminders`,\r\n      );\r\n      expect(mockResponse.json).toHaveBeenCalled();\r\n      expect(reminders).toEqual([{ id: '1', ...mockReminder }]);\r\n    });\r\n  });\r\n\r\n  describe('getReminder', () => {\r\n    it('should fetch a single reminder from the API', async () => {\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce({ id: '1', ...mockReminder }),\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const reminder = await getReminder('1');\r\n\r\n      expect(global.fetch).toHaveBeenCalledWith(\r\n        `${API_BASE_URL}/api/reminders/1`,\r\n      );\r\n      expect(mockResponse.json).toHaveBeenCalled();\r\n      expect(reminder).toEqual({ id: '1', ...mockReminder });\r\n    });\r\n  });\r\n\r\n  describe('createReminder', () => {\r\n    it('should create a new reminder', async () => {\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce({ id: '1', ...mockReminder }),\r\n        ok: true,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const createdReminder = await createReminder(mockReminder);\r\n\r\n      expect(global.fetch).toHaveBeenCalledWith(\r\n        `${API_BASE_URL}/api/reminders`,\r\n        {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify(mockReminder),\r\n        },\r\n      );\r\n      expect(mockResponse.json).toHaveBeenCalled();\r\n      expect(createdReminder.result).toEqual({ id: '1', ...mockReminder });\r\n    });\r\n\r\n    it('should return validation error when trying to create a new reminder', async () => {\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce(mockValidationFail),\r\n        ok: false,\r\n        status: 400,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      expect((await createReminder(mockReminder)).errors).toStrictEqual({\r\n        Title: mockValidationFail.errors['Title'],\r\n        Description: mockValidationFail.errors['Description'],\r\n        'LimitDate.Date': mockValidationFail.errors['LimitDate.Date'],\r\n      } as Errors);\r\n    });\r\n  });\r\n\r\n  describe('updateReminder', () => {\r\n    it('should update an existing reminder', async () => {\r\n      const updatedReminder = { id: '1', ...mockReminder };\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce(updatedReminder),\r\n        ok: true,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const reminder = await updateReminder(updatedReminder);\r\n\r\n      expect(global.fetch).toHaveBeenCalledWith(\r\n        `${API_BASE_URL}/api/reminders/1`,\r\n        {\r\n          method: 'PUT',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify(updatedReminder),\r\n        },\r\n      );\r\n      expect(mockResponse.json).toHaveBeenCalled();\r\n      expect(reminder.result).toEqual(updatedReminder);\r\n    });\r\n\r\n    it('should return validation error when trying to update a new reminder', async () => {\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce(mockValidationFail),\r\n        ok: false,\r\n        status: 400,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      expect((await updateReminder(mockReminder)).errors).toStrictEqual({\r\n        Title: mockValidationFail.errors['Title'],\r\n        Description: mockValidationFail.errors['Description'],\r\n        'LimitDate.Date': mockValidationFail.errors['LimitDate.Date'],\r\n      } as any);\r\n    });\r\n  });\r\n\r\n  describe('deleteReminder', () => {\r\n    it('should delete an existing reminder', async () => {\r\n      const mockResponse = {\r\n        ok: true,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const result = await deleteReminder('1');\r\n\r\n      expect(global.fetch).toHaveBeenCalledWith(\r\n        `${API_BASE_URL}/api/reminders/1`,\r\n        {\r\n          method: 'DELETE',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n        },\r\n      );\r\n      expect(result.result).toEqual('1');\r\n    });\r\n\r\n    it('should throw error if delete failed', async () => {\r\n      const mockResponse = {\r\n        json: jest\r\n          .fn()\r\n          .mockResolvedValueOnce({ ...mockValidationFail, errors: [] }),\r\n        ok: false,\r\n        status: 400,\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      expect((await deleteReminder('1')).errors).toStrictEqual({\r\n        BadRequest: mockValidationFail.title,\r\n      } as Errors);\r\n    });\r\n  });\r\n\r\n  describe('mapReminder', () => {\r\n    it('should limitDateFormatted be empty when no limit date is provided', async () => {\r\n      const copy = {\r\n        ...mockReminder,\r\n        limitDate: null,\r\n        limitDateFormatted: '',\r\n      };\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce({ id: '1', ...copy }),\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const reminder = await getReminder('1');\r\n\r\n      expect(reminder).toEqual({ id: '1', ...copy });\r\n    });\r\n\r\n    it('should isDoneFormatted be Yes when isDone is true', async () => {\r\n      const copy = {\r\n        ...mockReminder,\r\n        isDone: true,\r\n        isDoneFormatted: 'Yes',\r\n      };\r\n      const mockResponse = {\r\n        json: jest.fn().mockResolvedValueOnce({ id: '1', ...copy }),\r\n      };\r\n      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);\r\n\r\n      const reminder = await getReminder('1');\r\n\r\n      expect(reminder).toEqual({ id: '1', ...copy });\r\n    });\r\n  });\r\n\r\n  describe('getErrors', () => {\r\n    it('should return internal error when exception occurred', async () => {\r\n      const consoleSpy = jest\r\n        .spyOn(console, 'error')\r\n        .mockImplementationOnce(jest.fn);\r\n      const errorMessage = 'Error';\r\n      const mockResponse = {\r\n        json: jest.fn().mockRejectedValue(errorMessage),\r\n      } as any;\r\n\r\n      expect(await getErrors(mockResponse)).toStrictEqual({\r\n        InternalServer: 'Failed to perform errors validation',\r\n      } as Errors);\r\n      expect(consoleSpy).toHaveBeenCalledWith(errorMessage);\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\api\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\AlertError\\index.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\AlertError\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\ReminderDeleteModal\\index.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\ReminderDeleteModal\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\ReminderForm\\index.test.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (106). Maximum allowed is 50.","line":12,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":139,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Async arrow function has too many statements (11). Maximum allowed is 10.","line":99,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":138,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport userEvent from '@testing-library/user-event';\r\nimport { ReminderForm } from '.';\r\nimport { mockReminder } from '@/app/util/testMocks';\r\n\r\njest.mock(\r\n  '@/app/hooks',\r\n  require('@/app/util/testMocks').jestFunctionsMock['@/app/hooks'],\r\n);\r\n\r\ndescribe('ReminderForm', () => {\r\n  afterEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  it('should render without errors', async () => {\r\n    render(<ReminderForm />);\r\n\r\n    expect(screen.findByLabelText('Title')).resolves.toBeInTheDocument();\r\n    expect(screen.findByLabelText('Description')).resolves.toBeInTheDocument();\r\n    expect(screen.findByLabelText('Limit Date')).resolves.toBeInTheDocument();\r\n  });\r\n\r\n  it('should render without errors editing', async () => {\r\n    render(<ReminderForm editing />);\r\n\r\n    expect(screen.queryByLabelText('Id')).toBeInTheDocument();\r\n    expect(screen.findByLabelText('Title')).resolves.toBeInTheDocument();\r\n    expect(screen.findByLabelText('Description')).resolves.toBeInTheDocument();\r\n    expect(screen.findByLabelText('Limit Date')).resolves.toBeInTheDocument();\r\n    expect(screen.queryByLabelText('Done')).toBeInTheDocument();\r\n    expect(screen.queryByLabelText('Done')).toBeChecked();\r\n  });\r\n\r\n  it('handles user input correctly', async () => {\r\n    render(<ReminderForm />);\r\n\r\n    fireEvent.change(screen.getByTestId('title'), {\r\n      target: { value: 'Updated Title' },\r\n    });\r\n    fireEvent.change(screen.getByTestId('description'), {\r\n      target: { value: 'Updated Description' },\r\n    });\r\n    fireEvent.change(screen.getByTestId('limitDate'), {\r\n      target: { value: '2023-12-31' },\r\n    });\r\n\r\n    expect(screen.findByTestId('title')).resolves.toHaveValue('Updated Title');\r\n    expect(screen.findByTestId('description')).resolves.toHaveValue(\r\n      'Updated Description',\r\n    );\r\n    expect(screen.findByTestId('limitDate')).resolves.toHaveValue('2023-12-31');\r\n  });\r\n\r\n  it('should display the error messages correctly', () => {\r\n    render(<ReminderForm />);\r\n\r\n    jest.spyOn(console, 'error').mockImplementation(() => {});\r\n\r\n    fireEvent.change(screen.getByTestId('title'), { target: { value: '' } });\r\n    fireEvent.change(screen.getByTestId('description'), {\r\n      target: { value: '' },\r\n    });\r\n    fireEvent.change(screen.getByTestId('limitDate'), {\r\n      target: { value: '' },\r\n    });\r\n\r\n    expect(\r\n      screen.findByText('Title cannot be empty'),\r\n    ).resolves.toBeInTheDocument();\r\n    expect(\r\n      screen.findByText('Description cannot be empty'),\r\n    ).resolves.toBeInTheDocument();\r\n    expect(\r\n      screen.findByText('Limit Date cannot be empty'),\r\n    ).resolves.toBeInTheDocument();\r\n  });\r\n\r\n  it('should handles \"Done\" checkbox correctly in editing mode', async () => {\r\n    render(<ReminderForm editing />);\r\n\r\n    expect(screen.getByLabelText('Done')).toBeInTheDocument();\r\n\r\n    fireEvent.change(screen.getByTestId('isDone'), {\r\n      target: { checked: false },\r\n    });\r\n\r\n    expect(await screen.findByTestId('isDone')).not.toBeChecked();\r\n  });\r\n\r\n  it('should hide Id and IsDone when not editing', async () => {\r\n    render(<ReminderForm />);\r\n\r\n    expect(screen.queryByTestId('reminderId')).not.toBeInTheDocument();\r\n    expect(screen.queryByTestId('isDone')).not.toBeInTheDocument();\r\n  });\r\n\r\n  it('should call dispatch', async () => {\r\n    const dispatch = jest.fn();\r\n    jest\r\n      .spyOn(require('@/app/hooks'), 'useRemindersContext')\r\n      .mockImplementation(() => ({\r\n        reminder: mockReminder,\r\n        dispatch,\r\n      }));\r\n\r\n    render(<ReminderForm editing />);\r\n\r\n    fireEvent.change(screen.getByTestId('title'), {\r\n      target: { value: 'Updated Title' },\r\n    });\r\n    fireEvent.change(screen.getByTestId('description'), {\r\n      target: { value: 'Updated Description' },\r\n    });\r\n    fireEvent.change(screen.getByTestId('limitDate'), {\r\n      target: { value: '2023-12-31' },\r\n    });\r\n\r\n    await userEvent.click(screen.getByTestId('isDone'));\r\n\r\n    expect(dispatch).toHaveBeenCalledWith({\r\n      type: 'UPDATE_REMINDER',\r\n      payload: { title: 'Updated Title' },\r\n    });\r\n    expect(dispatch).toHaveBeenCalledWith({\r\n      type: 'UPDATE_REMINDER',\r\n      payload: { description: 'Updated Description' },\r\n    });\r\n    expect(dispatch).toHaveBeenCalledWith({\r\n      type: 'UPDATE_REMINDER',\r\n      payload: { limitDate: '2023-12-31' },\r\n    });\r\n    expect(dispatch).toHaveBeenCalledWith({\r\n      type: 'UPDATE_REMINDER',\r\n      payload: { isDone: false },\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\ReminderForm\\index.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'ReminderForm' has too many lines (80). Maximum allowed is 50.","line":10,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":96,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Box, Checkbox, FormControlLabel, TextField } from '@mui/material';\r\nimport type { InputHTMLAttributes } from 'react';\r\nimport { AlertError } from '..';\r\nimport { useRemindersContext } from '@/app/hooks';\r\n\r\ninterface Props {\r\n  editing?: boolean;\r\n}\r\n\r\nexport function ReminderForm({ editing = false }: Props) {\r\n  const { reminder, errors, dispatch } = useRemindersContext();\r\n\r\n  const handleChange = (key: string, value: string | boolean) => {\r\n    dispatch({ type: 'UPDATE_REMINDER', payload: { [key]: value } });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <AlertError error={errors?.InternalServer} />\r\n\r\n      {editing && (\r\n        <Box sx={{ mb: 2 }}>\r\n          <TextField\r\n            label=\"Id\"\r\n            defaultValue={reminder?.id || ''}\r\n            disabled\r\n            fullWidth\r\n            InputLabelProps={{ shrink: true }}\r\n            inputProps={{ readOnly: true, 'data-testid': 'reminderId' }}\r\n          />\r\n        </Box>\r\n      )}\r\n\r\n      <Box sx={{ mb: 2 }}>\r\n        <TextField\r\n          label=\"Title\"\r\n          placeholder=\"Enter title\"\r\n          defaultValue={reminder?.title || ''}\r\n          onChange={e => handleChange('title', e.target.value)}\r\n          required\r\n          fullWidth\r\n          error={Boolean(errors?.Title)}\r\n          helperText={errors?.Title}\r\n          InputLabelProps={{ shrink: true }}\r\n          inputProps={{ 'data-testid': 'title' }}\r\n        />\r\n      </Box>\r\n\r\n      <Box sx={{ mb: 2 }}>\r\n        <TextField\r\n          label=\"Description\"\r\n          placeholder=\"Enter description\"\r\n          defaultValue={reminder?.description || ''}\r\n          onChange={e => handleChange('description', e.target.value)}\r\n          required\r\n          fullWidth\r\n          InputLabelProps={{ shrink: true }}\r\n          error={Boolean(errors?.Description)}\r\n          helperText={errors?.Description}\r\n          inputProps={{ 'data-testid': 'description' }}\r\n        />\r\n      </Box>\r\n\r\n      <Box sx={{ mb: 2 }}>\r\n        <TextField\r\n          label=\"Limit Date\"\r\n          placeholder=\"Enter limit date\"\r\n          defaultValue={reminder?.limitDateFormatted || ''}\r\n          onChange={e => handleChange('limitDate', e.target.value)}\r\n          required\r\n          type=\"date\"\r\n          fullWidth\r\n          InputLabelProps={{ shrink: true }}\r\n          error={Boolean(errors?.['LimitDate.Date'])}\r\n          helperText={errors?.['LimitDate.Date']}\r\n          inputProps={{ 'data-testid': 'limitDate' }}\r\n        />\r\n      </Box>\r\n\r\n      {editing && (\r\n        <Box sx={{ mb: 2 }}>\r\n          <FormControlLabel\r\n            label=\"Done\"\r\n            control={\r\n              <Checkbox\r\n                checked={reminder?.isDone || false}\r\n                onChange={e => handleChange('isDone', e.target.checked)}\r\n                inputProps={{ 'data-testid': 'isDone' } as InputHTMLAttributes<HTMLInputElement>}\r\n              />\r\n            }\r\n          />\r\n        </Box>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\hooks\\useReminderContext\\index.test.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (57). Maximum allowed is 50.","line":29,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":93,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (11). Maximum allowed is 10.","line":29,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":93,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (200). Maximum allowed is 50.","line":95,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":361,"endColumn":2},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":118,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":120,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":143,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":145,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":160,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":162,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":177,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":179,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":202,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":204,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":219,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":221,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":236,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":238,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":261,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":263,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":281,"column":17,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":283,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":294,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":296,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":300,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":302,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":318,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":320,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":324,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":326,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":334,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":334,"endColumn":67},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":342,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":342,"endColumn":39},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":346,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":348,"endColumn":8},{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":354,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":356,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  act,\r\n  fireEvent,\r\n  render,\r\n  renderHook,\r\n  screen,\r\n  waitFor,\r\n} from '@testing-library/react';\r\nimport {\r\n  ReminderActionStatus,\r\n  RemindersContextProvider,\r\n  useRemindersClearContext,\r\n  useRemindersContext,\r\n} from '.';\r\nimport { ReactNode, useState } from 'react';\r\nimport { mockReminder } from '@/app/util/testMocks';\r\nimport { useReminderActions } from '@/app/api';\r\nimport React from 'react';\r\n\r\njest.mock(\r\n  'next/navigation',\r\n  () => require('@/app/util/testMocks').jestObjectsMock['next/navigation'],\r\n);\r\njest.mock(\r\n  '@/app/api',\r\n  () => require('@/app/util/testMocks').jestObjectsMock['@/app/api'],\r\n);\r\n\r\nconst TestingComponent = ({ title }: { title?: string }) => {\r\n  const {\r\n    reminder,\r\n    errors,\r\n    onCreateReminder,\r\n    onUpdateReminder,\r\n    onDeleteReminder,\r\n    clearReminder,\r\n    dispatch,\r\n  } = useRemindersContext();\r\n  const clearReminderFromClearContext = useRemindersClearContext();\r\n  const [result, setResult] = useState(ReminderActionStatus.Unknown);\r\n\r\n  const handleCreateClick = async () => {\r\n    setResult(await onCreateReminder());\r\n  };\r\n\r\n  const handleUpdateClick = async () => {\r\n    setResult(await onUpdateReminder());\r\n  };\r\n\r\n  const handleDeleteClick = async () => {\r\n    setResult(await onDeleteReminder());\r\n  };\r\n\r\n  const handleClearReminder = async () => {\r\n    clearReminder();\r\n  };\r\n\r\n  const handleUpdateDispatch = async () => {\r\n    dispatch({\r\n      type: 'UPDATE_REMINDER',\r\n      payload: { ...reminder, title },\r\n    });\r\n  };\r\n\r\n  const handleTypeWrongType = async () => {\r\n    dispatch({\r\n      type: 'WRONG_TYPE!_',\r\n    } as any);\r\n  };\r\n\r\n  const mapError = (error?: string[]) => error && error[0];\r\n\r\n  return (\r\n    <>\r\n      <button onClick={handleCreateClick}>Create</button>\r\n      <button onClick={handleUpdateClick}>Update</button>\r\n      <button onClick={handleDeleteClick}>Delete</button>\r\n      <button onClick={handleClearReminder}>Clear</button>\r\n      <button onClick={handleUpdateDispatch}>Update Dispatch</button>\r\n      <button onClick={handleTypeWrongType}>Wrong Type</button>\r\n      <button onClick={clearReminderFromClearContext}>\r\n        Clear from Clear Context\r\n      </button>\r\n      <span>{result}</span>\r\n      <span>{mapError(errors?.['LimitDate.Date'])}</span>\r\n      <span>{mapError(errors?.Description)}</span>\r\n      <span>{mapError(errors?.Title)}</span>\r\n      <span>{errors?.InternalServer}</span>\r\n      <span>{errors?.BadRequest}</span>\r\n      <span>{reminder?.title}</span>\r\n    </>\r\n  );\r\n};\r\n\r\ndescribe('RemindersContextProvider Tests', () => {\r\n  const mockErrors = {\r\n    Title: [\"The field Title must be a text with a maximum length of '50'.\"],\r\n    Description: [\r\n      \"The field Description must be a text with a maximum length of '200'.\",\r\n    ],\r\n    'LimitDate.Date': ['The Limit Date should be later than Today.'],\r\n  };\r\n\r\n  async function renderProvider(children: ReactNode) {\r\n    await act(async () => {\r\n      render(<RemindersContextProvider>{children}</RemindersContextProvider>);\r\n    });\r\n  }\r\n\r\n  afterEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  describe('createReminder', () => {\r\n    it('should update context values on successful createReminder', async () => {\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Create'));\r\n      });\r\n\r\n      const { createReminder } = useReminderActions();\r\n\r\n      expect(createReminder.mutateAsync).toHaveBeenCalledWith(mockReminder);\r\n\r\n      expect(\r\n        screen.getByText(ReminderActionStatus.Success),\r\n      ).toBeInTheDocument();\r\n    });\r\n\r\n    it('should handle exception on createReminder', async () => {\r\n      const consoleSpy = jest\r\n        .spyOn(console, 'error')\r\n        .mockImplementation(jest.fn);\r\n      const errorMessage = 'Error';\r\n\r\n      const { createReminder } = useReminderActions();\r\n\r\n      jest.spyOn(createReminder, 'mutateAsync').mockRejectedValue(errorMessage);\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Create'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(consoleSpy).toHaveBeenCalledWith(errorMessage);\r\n    });\r\n\r\n    it('should handle errors on updateReminder', async () => {\r\n      const { createReminder } = useReminderActions();\r\n\r\n      jest.spyOn(createReminder, 'mutateAsync').mockResolvedValue({\r\n        errors: mockErrors,\r\n      });\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Create'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(screen.getByText(mockErrors.Title[0])).toBeInTheDocument();\r\n      expect(screen.getByText(mockErrors.Description[0])).toBeInTheDocument();\r\n      expect(\r\n        screen.getByText(mockErrors['LimitDate.Date'][0]),\r\n      ).toBeInTheDocument();\r\n    });\r\n  });\r\n\r\n  describe('updateReminder', () => {\r\n    it('should update context values on successful updateReminder', async () => {\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Update'));\r\n      });\r\n\r\n      const { updateReminder } = useReminderActions();\r\n\r\n      expect(updateReminder.mutateAsync).toHaveBeenCalledWith(mockReminder);\r\n\r\n      expect(\r\n        screen.getByText(ReminderActionStatus.Success),\r\n      ).toBeInTheDocument();\r\n    });\r\n\r\n    it('should handle exception on updateReminder', async () => {\r\n      const consoleSpy = jest\r\n        .spyOn(console, 'error')\r\n        .mockImplementation(jest.fn);\r\n      const errorMessage = 'Error';\r\n\r\n      const { updateReminder } = useReminderActions();\r\n\r\n      jest.spyOn(updateReminder, 'mutateAsync').mockRejectedValue(errorMessage);\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Update'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(consoleSpy).toHaveBeenCalledWith(errorMessage);\r\n    });\r\n\r\n    it('should handle errors on updateReminder', async () => {\r\n      const { updateReminder } = useReminderActions();\r\n\r\n      jest.spyOn(updateReminder, 'mutateAsync').mockResolvedValue({\r\n        errors: mockErrors,\r\n      });\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Update'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(screen.getByText(mockErrors.Title[0])).toBeInTheDocument();\r\n      expect(screen.getByText(mockErrors.Description[0])).toBeInTheDocument();\r\n      expect(\r\n        screen.getByText(mockErrors['LimitDate.Date'][0]),\r\n      ).toBeInTheDocument();\r\n    });\r\n  });\r\n\r\n  describe('deleteReminder', () => {\r\n    it('should update context values on successful on deleteReminder', async () => {\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Delete'));\r\n      });\r\n\r\n      const { deleteReminder } = useReminderActions();\r\n\r\n      expect(deleteReminder.mutateAsync).toHaveBeenCalledWith(mockReminder.id);\r\n\r\n      expect(\r\n        screen.getByText(ReminderActionStatus.Success),\r\n      ).toBeInTheDocument();\r\n    });\r\n\r\n    it('should handle exception on deleteReminder', async () => {\r\n      const consoleSpy = jest\r\n        .spyOn(console, 'error')\r\n        .mockImplementation(jest.fn);\r\n      const errorMessage = 'Error';\r\n\r\n      const { deleteReminder } = useReminderActions();\r\n\r\n      jest.spyOn(deleteReminder, 'mutateAsync').mockRejectedValue(errorMessage);\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Delete'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(consoleSpy).toHaveBeenCalledWith(errorMessage);\r\n    });\r\n\r\n    it('should handle errors on deleteReminder', async () => {\r\n      const { deleteReminder } = useReminderActions();\r\n      const deleteError = {\r\n        BadRequest: 'Error',\r\n      };\r\n\r\n      jest.spyOn(deleteReminder, 'mutateAsync').mockResolvedValue({\r\n        errors: deleteError,\r\n      });\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await act(async () => {\r\n        fireEvent.click(screen.getByText('Delete'));\r\n      });\r\n\r\n      expect(screen.getByText(ReminderActionStatus.Fail)).toBeInTheDocument();\r\n      expect(screen.getByText(deleteError.BadRequest)).toBeInTheDocument();\r\n    });\r\n  });\r\n\r\n  describe('clearReminder', () => {\r\n    it('should call clearReminder from Default Context', async () => {\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      await waitFor(() => {\r\n        expect(screen.getByText(mockReminder.title)).toBeInTheDocument();\r\n      });\r\n\r\n      fireEvent.click(screen.getByText('Clear'));\r\n\r\n      await waitFor(() => {\r\n        expect(screen.queryByText(mockReminder.title)).not.toBeInTheDocument();\r\n      });\r\n    });\r\n\r\n    it('should call clearReminder from Clear Context', async () => {\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      fireEvent.click(screen.getByText('Clear from Clear Context'));\r\n    });\r\n  });\r\n\r\n  describe('dispatch', () => {\r\n    it('should call type UPDATE_REMINDER', async () => {\r\n      const title = 'Update by Test';\r\n\r\n      await renderProvider(<TestingComponent title={title} />);\r\n\r\n      await waitFor(() => {\r\n        expect(screen.getByText(mockReminder.title)).toBeInTheDocument();\r\n      });\r\n\r\n      fireEvent.click(screen.getByText('Update Dispatch'));\r\n\r\n      await waitFor(() => {\r\n        expect(screen.getByText(title)).toBeInTheDocument();\r\n      });\r\n    });\r\n\r\n    it('should throw error when call type not found', async () => {\r\n      jest.spyOn(console, 'error').mockImplementation(jest.fn);\r\n\r\n      await renderProvider(<TestingComponent />);\r\n\r\n      expect(() => fireEvent.click(screen.getByText('Wrong Type'))).toThrow();\r\n    });\r\n  });\r\n\r\n  describe('use Contexts', () => {\r\n    beforeEach(() => {\r\n      jest\r\n        .spyOn(require('use-context-selector'), 'useContextSelector')\r\n        .mockImplementation(() => null);\r\n    });\r\n\r\n    it('should useRemindersContext throw error when context not within provider', async () => {\r\n      expect(() => {\r\n        useRemindersContext();\r\n      }).toThrow(\r\n        'useRemindersContext must be used within a RemindersContextProvider',\r\n      );\r\n    });\r\n\r\n    it('should useRemindersClearContext throw error when context not within provider', async () => {\r\n      expect(() => {\r\n        useRemindersClearContext();\r\n      }).toThrow(\r\n        'useRemindersClearContext must be used within a RemindersContextProvider',\r\n      );\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\hooks\\useReminderContext\\index.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'RemindersContextProvider' has too many lines (86). Maximum allowed is 50.","line":77,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":187,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Function 'RemindersContextProvider' has too many statements (13). Maximum allowed is 10.","line":77,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":187,"endColumn":2},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'defaultReminder'. Either include it or remove the dependency array.","line":170,"column":6,"nodeType":"ArrayExpression","endLine":170,"endColumn":30,"suggestions":[{"desc":"Update the dependencies array to be: [defaultReminder, dispatch, reminderData]","fix":{"range":[4308,4332],"text":"[defaultReminder, dispatch, reminderData]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { Dispatch, ReactNode, useEffect, useReducer, useState } from 'react';\r\nimport { createContext, useContextSelector } from 'use-context-selector';\r\nimport { useParams } from 'next/navigation';\r\n\r\nimport { Errors, Reminder, useReminder, useReminderActions } from '@/app/api';\r\n\r\ninterface RemindersContextValue {\r\n  reminder?: Reminder | null | undefined;\r\n  errors?: Errors;\r\n  dispatch: Dispatch<ReminderAction>;\r\n  onCreateReminder: () => Promise<ReminderActionStatus>;\r\n  onUpdateReminder: () => Promise<ReminderActionStatus>;\r\n  onDeleteReminder: () => Promise<ReminderActionStatus>;\r\n  clearReminder: () => void;\r\n}\r\n\r\nexport enum ReminderActionStatus {\r\n  Unknown,\r\n  Success,\r\n  Fail,\r\n}\r\n\r\nconst RemindersContext = createContext<RemindersContextValue | undefined>(\r\n  undefined,\r\n);\r\n\r\nexport function useRemindersContext() {\r\n  const context = useContextSelector(RemindersContext, state => state);\r\n\r\n  if (!context) {\r\n    throw new Error(\r\n      'useRemindersContext must be used within a RemindersContextProvider',\r\n    );\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\nexport function useRemindersClearContext() {\r\n  const context = useContextSelector(\r\n    RemindersContext,\r\n    state => state?.clearReminder,\r\n  );\r\n\r\n  if (!context) {\r\n    throw new Error(\r\n      'useRemindersClearContext must be used within a RemindersContextProvider',\r\n    );\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\ntype ReminderAction =\r\n  | { type: 'SET_REMINDER'; payload: Reminder }\r\n  | { type: 'UPDATE_REMINDER'; payload: Partial<Reminder> }\r\n  | { type: 'CLEAR_REMINDER' };\r\n\r\nconst reminderReducer = (\r\n  state: Reminder | null,\r\n  action: ReminderAction,\r\n): Reminder | null => {\r\n  switch (action.type) {\r\n    case 'SET_REMINDER':\r\n      return action.payload;\r\n    case 'UPDATE_REMINDER':\r\n      return { ...state, ...action.payload } as Reminder | null;\r\n    case 'CLEAR_REMINDER':\r\n      return null;\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n\r\nexport function RemindersContextProvider({\r\n  children,\r\n}: {\r\n  children: ReactNode;\r\n}) {\r\n  const { id } = useParams<{ id: string }>();\r\n\r\n  const { data: reminderData } = useReminder(id);\r\n  const { createReminder, updateReminder, deleteReminder } = useReminderActions();\r\n\r\n  // Default reminder for creation\r\n  const defaultReminder = {\r\n    title: '',\r\n    description: '',\r\n    limitDate: '',\r\n    isDone: false,\r\n  };\r\n\r\n  // If on create page (no id), initialize with defaultReminder\r\n  const [reminder, dispatch] = useReducer(\r\n    reminderReducer,\r\n    id ? null : defaultReminder\r\n  );\r\n\r\n  const [errors, setErrors] = useState<Errors>();\r\n\r\n  const onCreateReminder = async (): Promise<ReminderActionStatus> => {\r\n    try {\r\n      if (reminder) {\r\n        const result = await createReminder.mutateAsync(reminder);\r\n\r\n        if (result?.errors && Object.keys(result?.errors).length > 0) {\r\n          setErrors(result?.errors);\r\n\r\n          return ReminderActionStatus.Fail;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n\r\n      return ReminderActionStatus.Fail;\r\n    }\r\n\r\n    return ReminderActionStatus.Success;\r\n  };\r\n\r\n  const onUpdateReminder = async (): Promise<ReminderActionStatus> => {\r\n    try {\r\n      if (reminder) {\r\n        const result = await updateReminder.mutateAsync(reminder);\r\n\r\n        if (result?.errors && Object.keys(result?.errors).length > 0) {\r\n          setErrors(result?.errors);\r\n\r\n          return ReminderActionStatus.Fail;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n\r\n      return ReminderActionStatus.Fail;\r\n    }\r\n\r\n    return ReminderActionStatus.Success;\r\n  };\r\n\r\n  const onDeleteReminder = async (): Promise<ReminderActionStatus> => {\r\n    try {\r\n      const result = await deleteReminder.mutateAsync(id);\r\n\r\n      if (result?.errors) {\r\n        setErrors(result?.errors);\r\n\r\n        return ReminderActionStatus.Fail;\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n\r\n      return ReminderActionStatus.Fail;\r\n    }\r\n\r\n    return ReminderActionStatus.Success;\r\n  };\r\n\r\n  const clearReminder = () => {\r\n    dispatch({ type: 'CLEAR_REMINDER' });\r\n    setErrors(undefined);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (reminderData) {\r\n      dispatch({ type: 'SET_REMINDER', payload: { ...defaultReminder, ...reminderData } });\r\n    }\r\n  }, [dispatch, reminderData]);\r\n\r\n  const value: RemindersContextValue = {\r\n    reminder,\r\n    errors,\r\n    dispatch,\r\n    onCreateReminder,\r\n    onUpdateReminder,\r\n    onDeleteReminder,\r\n    clearReminder,\r\n  };\r\n\r\n  return (\r\n    <RemindersContext.Provider value={value}>\r\n      {children}\r\n    </RemindersContext.Provider>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\hooks\\useRemindersQueryClient\\index.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\hooks\\useRemindersQueryClient\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\[id]\\edit-client.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'EditClient' has too many lines (56). Maximum allowed is 50.","line":11,"column":16,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":79,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { Suspense, useState } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\n\r\nimport { Button, Container, CircularProgress, Stack } from '@mui/material';\r\n\r\nimport { ReminderDeleteModal, ReminderForm } from '@/app/components';\r\nimport { ReminderActionStatus, useRemindersContext } from '@/app/hooks';\r\n\r\nexport default function EditClient() {\r\n  const router = useRouter();\r\n\r\n  const { onUpdateReminder, onDeleteReminder } = useRemindersContext();\r\n\r\n  const [openDelete, setOpenDelete] = useState(false);\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    const status = await onUpdateReminder();\r\n    \r\n    if (status === ReminderActionStatus.Success) {\r\n      handleBack();\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    const status = await onDeleteReminder();\r\n\r\n    if (status === ReminderActionStatus.Success) {\r\n      handleBack();\r\n    }\r\n  };\r\n\r\n  const toggleOpenDelete = () => {\r\n    setOpenDelete(state => !state);\r\n  };\r\n\r\n  const handleBack = () => {\r\n    router.push('/');\r\n  };\r\n\r\n  return (\r\n    <Suspense fallback={<CircularProgress />}>\r\n      <Container sx={{ margin: 3 }}>\r\n        <form onSubmit={handleSubmit} noValidate>\r\n          <Stack spacing={5}>\r\n            <ReminderForm editing />\r\n\r\n            <Stack direction=\"row\" spacing={2}>\r\n              <Button type=\"submit\" variant=\"contained\" color=\"success\">\r\n                Edit\r\n              </Button>\r\n              <Button\r\n                variant=\"contained\"\r\n                color=\"error\"\r\n                onClick={toggleOpenDelete}\r\n              >\r\n                Delete\r\n              </Button>\r\n              <Button variant=\"contained\" color=\"info\" onClick={handleBack}>\r\n                Back\r\n              </Button>\r\n            </Stack>\r\n          </Stack>\r\n        </form>\r\n\r\n        <ReminderDeleteModal\r\n          openDelete={openDelete}\r\n          toggleOpenDelete={toggleOpenDelete}\r\n          onDelete={handleDelete}\r\n        />\r\n      </Container>\r\n    </Suspense>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\[id]\\page.test.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (70). Maximum allowed is 50.","line":14,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":110,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, screen, fireEvent } from '@testing-library/react';\r\nimport Edit from './page';\r\nimport { ReminderActionStatus } from '@/app/hooks';\r\n\r\njest.mock(\r\n  'next/navigation',\r\n  require('@/app/util/testMocks').jestFunctionsMock['next/navigation'],\r\n);\r\njest.mock(\r\n  '@/app/hooks',\r\n  require('@/app/util/testMocks').jestFunctionsMock['@/app/hooks'],\r\n);\r\n\r\ndescribe('Edit Component', () => {\r\n  afterEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  it('should render Edit component', () => {\r\n    render(<Edit />);\r\n\r\n    expect(screen.getByText('Edit')).toBeInTheDocument();\r\n    expect(screen.getByText('Delete')).toBeInTheDocument();\r\n    expect(screen.getByText('Back')).toBeInTheDocument();\r\n  });\r\n\r\n  it('should call onUpdateReminder and handles form submission', async () => {\r\n    render(<Edit />);\r\n\r\n    fireEvent.click(screen.getByText('Edit'));\r\n\r\n    await screen.findByText('Back');\r\n\r\n    expect(\r\n      require('@/app/hooks').useRemindersContext().onUpdateReminder,\r\n    ).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).toHaveBeenCalledWith(\r\n      '/',\r\n    );\r\n  });\r\n\r\n  it('should call onUpdateReminder and not redirect', async () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks').useRemindersContext(), 'onUpdateReminder')\r\n      .mockResolvedValue(ReminderActionStatus.Fail);\r\n\r\n    render(<Edit />);\r\n\r\n    fireEvent.click(screen.getByText('Edit'));\r\n\r\n    await screen.findByText('Back');\r\n\r\n    expect(\r\n      require('@/app/hooks').useRemindersContext().onUpdateReminder,\r\n    ).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).not.toHaveBeenCalled();\r\n  });\r\n\r\n  it('should call onDeleteReminder and handles delete button click', async () => {\r\n    render(<Edit />);\r\n\r\n    fireEvent.click(screen.getByText('Delete'));\r\n\r\n    await screen.findByText('Are you sure you want to delete this reminder?');\r\n\r\n    const deleteButton = screen.getByTestId('delete-button');\r\n    fireEvent.click(deleteButton);\r\n\r\n    await screen.findByText('Back');\r\n\r\n    expect(\r\n      require('@/app/hooks').useRemindersContext().onDeleteReminder,\r\n    ).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).toHaveBeenCalledWith(\r\n      '/',\r\n    );\r\n  });\r\n\r\n  it('should call onDeleteReminder and not redirect', async () => {\r\n    jest\r\n      .spyOn(require('@/app/hooks').useRemindersContext(), 'onDeleteReminder')\r\n      .mockResolvedValue(ReminderActionStatus.Fail);\r\n\r\n    render(<Edit />);\r\n\r\n    fireEvent.click(screen.getByText('Delete'));\r\n\r\n    await screen.findByText('Are you sure you want to delete this reminder?');\r\n\r\n    const deleteButton = screen.getByTestId('delete-button');\r\n    fireEvent.click(deleteButton);\r\n\r\n    await screen.findByText('Back');\r\n\r\n    expect(\r\n      require('@/app/hooks').useRemindersContext().onDeleteReminder,\r\n    ).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).not.toHaveBeenCalled();\r\n  });\r\n\r\n  it('should handle Back button click', () => {\r\n    render(<Edit />);\r\n\r\n    fireEvent.click(screen.getByText('Back'));\r\n\r\n    expect(require('next/navigation').useRouter().push).toHaveBeenCalledWith(\r\n      '/',\r\n    );\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\[id]\\page.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'Edit' has too many lines (56). Maximum allowed is 50.","line":11,"column":16,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":79,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { Suspense, useState } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\n\r\nimport { Button, Container, Stack, CircularProgress } from '@mui/material';\r\n\r\nimport { ReminderDeleteModal, ReminderForm } from '@/app/components';\r\nimport { ReminderActionStatus, useRemindersContext } from '@/app/hooks';\r\n\r\nexport default function Edit() {\r\n  const router = useRouter();\r\n\r\n  const { onUpdateReminder, onDeleteReminder } = useRemindersContext();\r\n\r\n  const [openDelete, setOpenDelete] = useState(false);\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    const status = await onUpdateReminder();\r\n\r\n    if (status === ReminderActionStatus.Success) {\r\n      handleBack();\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    const status = await onDeleteReminder();\r\n\r\n    if (status === ReminderActionStatus.Success) {\r\n      handleBack();\r\n    }\r\n  };\r\n\r\n  const toggleOpenDelete = () => {\r\n    setOpenDelete(state => !state);\r\n  };\r\n\r\n  const handleBack = () => {\r\n    router.push('/');\r\n  };\r\n\r\n  return (\r\n    <Suspense fallback={<CircularProgress />}>\r\n      <Container sx={{ margin: 3 }}>\r\n        <form onSubmit={handleSubmit} noValidate>\r\n          <Stack spacing={5}>\r\n            <ReminderForm editing />\r\n\r\n            <Stack direction=\"row\" spacing={2}>\r\n              <Button type=\"submit\" variant=\"contained\" color=\"success\">\r\n                Edit\r\n              </Button>\r\n              <Button\r\n                variant=\"contained\"\r\n                color=\"error\"\r\n                onClick={toggleOpenDelete}\r\n              >\r\n                Delete\r\n              </Button>\r\n              <Button variant=\"contained\" color=\"info\" onClick={handleBack}>\r\n                Back\r\n              </Button>\r\n            </Stack>\r\n          </Stack>\r\n        </form>\r\n\r\n        <ReminderDeleteModal\r\n          openDelete={openDelete}\r\n          toggleOpenDelete={toggleOpenDelete}\r\n          onDelete={handleDelete}\r\n        />\r\n      </Container>\r\n    </Suspense>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\create\\page.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\create\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\list\\page.test.tsx","messages":[{"ruleId":"max-nested-callbacks","severity":1,"message":"Too many nested callbacks (4). Maximum allowed is 3.","line":27,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":37,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\r\nimport RemindersList from './page';\r\nimport { mockReminders } from '@/app/util/testMocks';\r\n\r\njest.mock(\r\n  'next/navigation',\r\n  require('@/app/util/testMocks').jestFunctionsMock['next/navigation'],\r\n);\r\njest.mock('@/app/api', require('@/app/util/testMocks').jestFunctionsMock['@/app/api']);\r\njest.mock(\r\n  '@/app/hooks',\r\n  require('@/app/util/testMocks').jestFunctionsMock['@/app/hooks'],\r\n);\r\n\r\ndescribe('RemindersList', () => {\r\n  afterEach(() => {\r\n    jest.restoreAllMocks();\r\n  });\r\n\r\n  it('should render without errors', async () => {\r\n    render(<RemindersList />);\r\n\r\n    expect(screen.getByText('Create Reminder')).toBeInTheDocument();\r\n\r\n    await waitFor(async () => {\r\n      mockReminders.forEach(mockReminder => {\r\n        expect(screen.getByText(mockReminder.id)).toBeInTheDocument();\r\n        expect(screen.getByText(mockReminder.title)).toBeInTheDocument();\r\n        expect(screen.getByText(mockReminder.description)).toBeInTheDocument();\r\n        expect(\r\n          screen.getByText(mockReminder.limitDateFormatted),\r\n        ).toBeInTheDocument();\r\n        expect(\r\n          screen.getByText(mockReminder.isDoneFormatted),\r\n        ).toBeInTheDocument();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('should handle Create Reminder click correctly', () => {\r\n    render(<RemindersList />);\r\n\r\n    fireEvent.click(screen.getByText('Create Reminder'));\r\n\r\n    expect(require('@/app/hooks').useRemindersClearContext).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).toHaveBeenCalledWith(\r\n      '/reminder/create',\r\n    );\r\n  });\r\n\r\n  it('should handle Edit click correctly', async () => {\r\n    render(<RemindersList />);\r\n\r\n    fireEvent.click(screen.getAllByText('Edit')[0]);\r\n\r\n    expect(require('@/app/hooks').useRemindersClearContext).toHaveBeenCalled();\r\n    expect(require('next/navigation').useRouter().push).toHaveBeenCalledWith(\r\n      '/reminder/1',\r\n    );\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\reminder\\list\\page.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'RemindersList' has too many lines (66). Maximum allowed is 50.","line":22,"column":16,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":91,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { Suspense } from 'react';\r\nimport Link from 'next/link';\r\nimport { useRouter } from 'next/navigation';\r\n\r\nimport {\r\n  Table,\r\n  TableBody,\r\n  TableCell,\r\n  TableContainer,\r\n  TableHead,\r\n  TableRow,\r\n  Paper,\r\n  Button,\r\n  CircularProgress,\r\n} from '@mui/material';\r\n\r\nimport { useRemindersClearContext } from '@/app/hooks';\r\nimport { useReminders } from '@/app/api';\r\n\r\nexport default function RemindersList() {\r\n  const router = useRouter();\r\n\r\n  const { data: reminders } = useReminders();\r\n  const clearReminder = useRemindersClearContext();\r\n\r\n  const handleCreateClick = () => {\r\n    clearReminder();\r\n    router.push('/reminder/create');\r\n  };\r\n\r\n  const handleEditClick = (id?: string) => {\r\n    clearReminder();\r\n    router.push(`/reminder/${id}`);\r\n  };\r\n\r\n  return (\r\n    <Suspense fallback={<CircularProgress />}>\r\n      <Link\r\n        href={'#'}\r\n        onClick={e => {\r\n          e.preventDefault();\r\n          handleCreateClick();\r\n        }}\r\n      >\r\n        <Button variant=\"contained\" color=\"primary\">\r\n          Create Reminder\r\n        </Button>\r\n      </Link>\r\n      <TableContainer component={Paper}>\r\n        <Table>\r\n          <TableHead>\r\n            <TableRow>\r\n              <TableCell>ID</TableCell>\r\n              <TableCell>Title</TableCell>\r\n              <TableCell>Description</TableCell>\r\n              <TableCell>Limit Date</TableCell>\r\n              <TableCell>Done</TableCell>\r\n              <TableCell></TableCell>\r\n            </TableRow>\r\n          </TableHead>\r\n          <TableBody>\r\n            {reminders?.map(reminder => (\r\n              <TableRow key={reminder.id}>\r\n                <TableCell>{reminder.id}</TableCell>\r\n                <TableCell>{reminder.title}</TableCell>\r\n                <TableCell>{reminder.description}</TableCell>\r\n                <TableCell>{reminder.limitDateFormatted}</TableCell>\r\n                <TableCell>{reminder.isDoneFormatted}</TableCell>\r\n                <TableCell>\r\n                  <Link\r\n                    href={'#'}\r\n                    onClick={e => {\r\n                      e.preventDefault();\r\n                      handleEditClick(reminder.id);\r\n                    }}\r\n                  >\r\n                    <Button variant=\"contained\" color=\"primary\">\r\n                      Edit\r\n                    </Button>\r\n                  </Link>\r\n                </TableCell>\r\n              </TableRow>\r\n            ))}\r\n          </TableBody>\r\n        </Table>\r\n      </TableContainer>\r\n    </Suspense>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]},{"filePath":"D:\\Repositories\\Learning\\Reminders\\src\\app\\reactjs\\reminders-app\\src\\app\\util\\testMocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-statements-per-line","replacedBy":[]}]}]
